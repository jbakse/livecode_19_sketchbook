import * as tree from "./js/tree.js";
import Path from "./js/path.js";
import * as nav from "./js/nav.js";
import builders from "./js/template_builders.js";
import settings from "./settings.js";

let sketchTree = null;

function determineSourceVisibility() {
  // source visibility is determined a few things:

  // 1. default true
  let visible = true;

  // 2. override with user preference if it exists
  const userPreference = window.localStorage.getItem("hide_source");
  if (userPreference !== null) visible = userPreference === "false";

  // 3. override with query parameter if it exists
  // show if present, hide if present but "false"
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has("showSource")) visible = true;
  if (urlParams.get("showSource") === "false") visible = false;

  // todo: add per filetype, filename, or metadata overrides

  return visible;
}
async function main() {
  // console greeting
  console.log("%c Sketchbook ", "color: yellow; background: #000;");

  // load the sketch tree, a json file that describes the structure of the sketches folder generated by a build script
  sketchTree = await tree.load("sketches_tree.json");

  // determine the full path of the sketch to display
  const urlParams = new URLSearchParams(window.location.search);
  const sketchPath = tree.defaultFile(
    sketchTree,
    urlParams.get("sketch") || ""
  );

  // log the sketch path
  console.log(`%c ${sketchPath} `, "color: yellow; background: #000;");

  // build the navigation ui
  nav.buildNav(sketchTree, sketchPath);

  // hide/show the source frame
  document
    .getElementById("source-frame")
    .classList.toggle("hidden", !determineSourceVisibility());

  // build the sketch based on the sketch extensions
  // a sketch might have multiple extensions (e.g. sketch.md.js => md.js)
  const sourcePath = settings.sketchesRoot + sketchPath;
  const extensions = Path.extensions(sourcePath);

  // check if there is a builder for the extension
  if (builders.hasOwnProperty(extensions)) {
    // use it
    builders[extensions](sourcePath);
  } else {
    // use the default builder
    builders.direct(sourcePath);
  }

  // install click handler on the source toggle button
  document.getElementById("toggle-source").onclick = () => {
    // toggle the source frame and get the current state
    const hidden = document
      .getElementById("source-frame")
      .classList.toggle("hidden");

    // save the state to local storage
    window.localStorage.setItem("hide_source", hidden.toString());

    // reflect state in url query string
    urlParams.set("showSource", (!hidden).toString());
    window.history.replaceState(
      null,
      "",
      window.location.pathname + "?" + urlParams.toString()
    );
  };
}

function updateSearch(input, ls) {
  const lis = ls.querySelectorAll("li.folder, li.file");

  // hide everything
  for (const li of lis) {
    li.classList.add("hidden");
  }

  // show matching items ("" matches everything)
  for (const li of lis) {
    // todo: reveal contents of matching folders
    // todo: fuzzy search would be nice
    if (li.innerText.toLowerCase().includes(input.value.toLowerCase())) {
      li.classList.remove("hidden");
    }
  }
}

main();

/// exported functions for sketch use

/**
 * ls
 *
 * function provided for listing the sketches from a html/md file in sketches
 */

window.ls = (path = "", maxDepth = 3, currentDepth = 1) => {
  // base case, if we've passed the max depth we are done
  if (currentDepth > maxDepth) return "";

  let markup = "<ul>";
  const branch = tree.getItem(sketchTree, path);

  // sort files before folders
  branch.children.sort((a, b) => {
    if (a.type === "file" && b.type === "folder") return -1;
    if (a.type === "folder" && b.type === "file") return 1;
    return 0;
  });

  // list children
  branch.children.forEach((item) => {
    // files are <li><a></a></li>
    if (item.type === "file") {
      markup += `<li class="file"><a class="file" href="?sketch=${path}/${item.name}">${item.name}</a></li>`;
    }
    // folders are <li><h#><a></a></h#>(sublist)</li>
    if (item.type === "folder") {
      markup += '<li class="folder">';
      markup += `<h${currentDepth + 1}>`;
      markup += `<a class="folder" href="?sketch=${path}/${item.name}">${item.name}</a>`;
      markup += "</h1>";
      markup += window.ls(`${path}/${item.name}`, maxDepth, currentDepth + 1);
      markup += "</li>";
    }
  });

  markup += "</ul>";
  return markup;
};

/**
 * initSearch
 *
 * function provided to allow html/md files to provide a search input
 *
 * @param inputElement - the input element to attach the search to
 * @param lsElement - the element containing files to search (window.ls output)
 */

window.initSearch = (inputElement, lsElement) => {
  inputElement.focus();
  inputElement.onkeyup = () => updateSearch(inputElement, lsElement);
};
