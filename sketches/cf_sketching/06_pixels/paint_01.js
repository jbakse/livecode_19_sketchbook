// require https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/p5.min.js

let mainImage;

// palette generated by ChatGPT March 6, 2023
// prompt: give me a spring-time palette as a json literal array of arrays of ints representing RGBA colors in the 0 to 255 range
const palette = [
  [250, 202, 204, 255], // Pale pink
  [250, 222, 176, 255], // Light yellow
  [150, 203, 187, 255], // Mint green
  [218, 165, 32, 255], // Goldenrod
  [252, 228, 236, 255], // Light pink
];
function setup() {
  createCanvas(512, 512);
  mainImage = createImage(512, 512);
  noiseDetail(4, 0.5);
  noLoop();
}

function draw() {
  background(palette[0]);

  mainImage.loadPixels();

  for (let i = 0; i < 1000; i++) {
    const x = randomInt(width);
    const y = randomInt(height);

    dab(x, y, 30, random(palette), i);
  }

  mainImage.updatePixels();

  noSmooth();
  image(mainImage, 0, 0, width, height);
}

function dab(x, y, r = 10, c = [255, 255, 255, 255], seed = 0) {
  for (let xx = x - r; xx < x + r; xx++) {
    for (let yy = y - r; yy < y + r; yy++) {
      // make a stipplely little circle
      const d = dist(xx, yy, x, y);
      const threshold = map(d, 0, r, 1, 0);
      if (random() < threshold) {
        // const n = map(noise(xx * 0.1, yy * 0.1, seed), 0, 1, 0.1, 0.5);
        // let cc = blendColor(c, [0, 0, 0, 0], n);
        // cc = blendColor(cc, [255, 255, 255, 255], map(yy, y - r, y + r, 0, 1));
        setPixel(mainImage, xx, yy, c);
      }
    }
  }
}

// math utils

function clamp(value, minimum, maximum) {
  if (value < minimum) return minimum;
  if (value > maximum) return maximum;
  return value;
}

function randomInt(a, b) {
  return floor(random(a, b));
}

function noiseInt(x, y, z, a, b) {
  noiseDetail(1);
  return floor(map(noise(x, y, z), 0, 0.5, a, b));
}

// color utils

function blendColor(a, b, mix) {
  return [
    lerp(a[0], b[0], mix),
    lerp(a[1], b[1], mix),
    lerp(a[2], b[2], mix),
    lerp(a[3], b[3], mix),
  ];
}

function lightestColor(a, b) {
  return [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]), max(a[3], b[3])];
}

function setPixel(img, x, y, color) {
  const clampX = clamp(x, 0, img.width);
  const clampY = clamp(y, 0, img.height);
  if (clampX !== x || clampY !== y) {
    return;
  }

  const i = (clampY * img.width + clampX) * 4;
  img.pixels[i] = color[0];
  img.pixels[i + 1] = color[1];
  img.pixels[i + 2] = color[2];
  img.pixels[i + 3] = color[3];
}

function getPixel(img, x, y) {
  const clampX = clamp(x, 0, img.width);
  const clampY = clamp(y, 0, img.height);
  if (clampX !== x || clampY !== y) {
    return [0, 0, 0, 0];
  }
  const i = (clampY * img.width + clampX) * 4;
  return [
    img.pixels[i],
    img.pixels[i + 1],
    img.pixels[i + 2],
    img.pixels[i + 3],
  ];
}

function keyPressed() {
  if (key === "S") {
    save("canvas.jpg");
  }
}
